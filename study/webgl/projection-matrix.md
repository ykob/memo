# プロジェクション座標変換

通常の3Dアプリケーションにはカメラがあるが、WebGLのAPI自体にあるのは行列だけであり、カメラオブジェクトに該当するものはない。 
WebGLでカメラを表現するためには4×4の行列を使用する必要がある。  

カメラを動かすと、それに併せてオブジェクトの表示を更新しなければならない。  
それには新しい視点に対応するように各頂点に規則的な座標変換を適用する必要がある。  
その際に重要なのが、カメラの移動後にオブジェクトの法線と光線の向きの一貫性を維持することである。つまり、頂点(位置)と法線(向き)それぞれの変換の仕方を理解する必要がある。

## 頂点変換

WebGLのシーンのオブジェクトには、スクリーン上に表示される前に様々な座標変換が適用される。  
それぞれの変換は4×4行列の形式で表現される。  
3次元ベクトルで表現される位置や向きに4×4行列を掛け合わせるには、タプルに一次元を追加して濃度を拡張すればよい。  
つまり、それぞれの頂点座標に同次座標と呼ばれる4番目の要素を追加する。

### 同次座標

同次座標を利用することで、アフィン変換（回転、拡大縮小、せん断変形、平行移動など）と4×4行列を使用した投影変換を表現できる。

同次座標系では頂点は `(x, y, z, w)` という4つの要素を持つ。  
最初の3つはユークリッド空間での頂点座標で、4番目が投影養素となる。  
4要素のタプル `(x, y, z, w)` を使用することで投影空間を定義することが出来る。

同次座標は各座標を `w` で割ることで非同次座標（旧来のユークリッド座標）に簡単に変換できる。  
逆にユークリッド空間から投影空間に変換するには `w` に1を追加すればよい。  
また `w` が `0` の同次座標は無限遠の点を表す。

頂点シェーダーにおいて、位置ベクトルの変換で頻繁に用いられる記述は以下のようになる。

```
vec4 mvPosition = ModelViewMatrix * vec4(position, 1.0);
```

### モデル変換

空間上でオブジェクトを変形させたり移動させたい場合、モデル行列を用いてオブジェクト座標をワールド座標に変換すればよい。  
頂点のオブジェクト座標にモデル行列をかけ合わせて得られる頂点座標が3D空間でのオブジェクトの位置になる。  

オブジェクト座標系では、各オブジェクトごとに定義された原点を元に、各頂点が原点からどの位置にあるのかを指定する。
ワールド座標系では、原点はすべてのオブジェクトで共通であり、オブジェクト同士がお互いにどのような位置関係にあるのかを知ることができる。
ワールド座標系でオブジェクトがどこにあるのかを指定することを**モデル変換**という。

### ビュー変換

ワールド座標系をビュー座標系に変換することを**ビュー変換**という。  
ビュー変換では座標系の原点をビューの原点（カメラ位置）に移動する。  
ビュー行列をモデル変換で得られた頂点座標に掛け合わせることで、ビューの原点をを基準とした新しい頂点座標を得ることができる。  
カメラの操作はこの座標系内で行う。

### 投影変換

投影変換ではビュー空間のどの範囲を描画するか、スクリーンにどのように対応付けるかを指定する。  
3D空間内の画面に描画される領域のことを**視錐台 (frustum)**と呼び、6つの平面(近平面、遠平面、上面、底面、右側面、左側面)で定義される。これら6つの平面は投影行列で表現される。  
視錐台の外にある頂点はすべて変換後に切り取られ、以降の処理では無視される。  
つまり、視錐台はクリッピング座標を定義し、投影行列はクリッピング座標を出力する。

近平面と遠平面の形状と大きさが同じだとその視錐台は平行投影を表す。  
そうでなければ透視投影になる。

この時点ではまだ同次座標を使用しているので、クリッピング座標は `(x, y, z, w)` で構成される。クリッピングを実現するには、`w` と `x, y, z` を比較する。いずれかが `+w` より大きいか、 `-w` より小さければ頂点は視錐台の外にあり無視される。

### 透視分割

ビュー空間のどの範囲を描画するかが決まると、視錐台は2D画像を生成するために近平面に投影される。つまり、近平面がスクリーンに描画される平面になる。  
WebGLとOpenGL ESは特定のハードウェアに依存しない中間的な座標を使用する。この空間を**正規化デバイス座標 (Normalized Device Coordinates: NDC)**と呼ぶ。

正規化デバイス座標はクリッピング座標を `w` で割ることで得られる。この手順を**透視分割 (perspective division)**と呼ぶ。  
NDCには3要素しかない。NDC空間では`x`, `y`座標は正規化された2Dスクリーン上の頂点の位置を表し、z座標は深度情報（近平面と遠平面を基準とするオブジェクト同士の相対的な位置）を表す。したがってこの時点では深度情報を維持している。WebGLはこの深度情報を使用して、近平面からの距離に基づいてオーバーラップしたオブジェクトをどのように表示するかを決定する。
透視分割を行った視錐台の座標は最小`(-1, -1, -1)`、最大`(1, 1, 1)`の立方体に変換される。

### ビューポート変換

最後にNDCをビューポート座標に対応付ける。この手順により座標がスクリーン上で利用可能な空間にマッピングされる。WebGLではこの空間はcanvas要素で提供される。  
ビューポート変換は行列変換で実現するわけではなく、WebGLの `viewport` 関数を利用する。

### 法線変換

頂点を変換する際には、それに合わせて法線ベクトルも正しい向きを示すように変換しなければならない。
モデルビュー行列を適用すれば実現できそうだが、適用するモデルビュー行列によっては法線が面に対して垂直ではなくなる場合がある。  
この問題はモデルビュー行列が異方性のある拡大縮小やせん断変形をしているときに発生する。  

法線ベクトルをオブジェクト表面に対して垂直に保つ行列を法線行列と呼ぶ。  
法線行列はモデルビュー行列の逆行列を転置することで得られる。

## 頂点返還の流れ

理論上では、以下の流れでオブジェクト座標がビューポート座標に変換される。

1. モデル変換
2. ビュー変換
3. 投影変換
4. 透視分割
5. ビューポート変換

これはWebGLの以下実装に対応する。

1. オブジェクト座標
2. モデルビュー行列 (モデル変換とビュー変換をひとつにまとめたもの)
3. 投影行列 (投影変換と透視分割をひとつにまとめたもの)
4. `gl.viewport`
5. ビューポート座標

## JavaScriptにおける行列演算

WebGL JavaScript API には行列操作を実現する独自のメソッドは存在しない。  
WebGLは行列をシェーダーに `uniform` として受け渡す手段を提供するのみなので、JavaScriptで行列を操作するにはそのためのJavaSciptライブラリを導入するなどの手順が必要になる。  
代表的な行列演算ライブラリに [glMatrix](https://glmatrix.net/) がある。

## 参考書籍

- [初めてのWebGL 2 第2版](https://www.oreilly.co.jp/books/9784873119373/)
- [Example](https://github.com/PacktPublishing/Real-Time-3D-Graphics-with-WebGL-2)
- [glMatrix](https://glmatrix.net/)