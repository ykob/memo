# React に関する基礎情報

## フック (hook)

フック(hook)は React 16.8 で追加された機能。  
React 16.8 の正式版がリリースされたのは2019年2月4日。  
それ以前のReactにおける関数コンポーネントはStatelessなものだったが、hookによってStatefullな関数コンポーネントを作成することができるようになった。

フックはAPIとしてはuseから始まる関数名で提供されている。(`useState`, `useEffect`など)  

## カスタムフック

## 副作用 (effect) フック

プログラミングにおける**副作用 (side effect)**とは、ある機能がデータを変化させた際にそれ以降の演算の結果に影響を与えたり、予測しにくい結果を生じさせることを言う。  
関数型プログラミングでは個々の関数が独立して定義されるため、副作用のリスクが小さくなるメリットがあるとも言われる。  

元々ネガティブな意味合いで使われていた副作用だが、Reactにおいてはその限りではなく、DOMやstateの更新を検知して実行したいコードを指して副作用と呼ぶことがある。  
副作用フックはそのための仕組として存在する。  

- クラスコンポーネントの場合 ... `componentDidMount` や `componentDidUpdate` を使う。
- 関数コンポーネントの場合 ... `useEffect` を使う。

`useEffect` はそのコンポーネントがレンダリングされる際に毎回呼び出される。  
コンポーネントの `props` が更新されるとそのコンポーネント自体も再レンダリングされるので、 `props` の更新に合わせてある処理を行いたい場合などに利用できる。(Vue.jsにおける `watch` に似ている。)

`useEffect` は非同期的に実行され、ブラウザによる画面更新をブロックしない。大部分において副作用は同期的に行われる必要がないためにそのようになっている。  
副作用の処理を同期的に行いたい場合(レアケース)は、 `useLayoutEffect` という別のフックを利用する必要がある。

## `useMemo` と `useCallback`

`useMemo` と `useCallback` はいずれも基本的にコンポーネントの再レンダリングを最適化するために用意されている。  
純粋なコンポーネントは、何も状態の変更が発生していないように見える場合でも、再レンダリングが行われていることがよくある。  
再レンダリングの最適化には主に次の2つの方法がある。

1. 特定のレンダリングで実行する必要がある作業の量を削減する。
2. コンポーネントの再レンダリングが必要になる回数を減らす。

`useMemo` はレンダリング内で計算された値を記憶できるようにする。  
小さなキャッシュなようなものであるとも言える。

## コンポーネントのメモ化 `React.memo`

Reactでは基本的に親コンポーネントが再レンダリングされると子コンポーネントも再レンダリングされてしまう。  
親コンポーネントの `state` が更新されると、それに関係しない子コンポーネントも再レンダリングされてしまうということになる。  
 `React.memo` で包含されたコンポーネントは、そのような無関係な更新による再レンダリングから保護される。

 ### 配列が `props` で渡されているコンポーネントのメモ化

通常値が参照渡しされる配列などが `props` に代入されている場合は、コンポーネントをメモ化していてかつ中身が更新されていないとしても、親コンポーネントが再レンダリングされると子も再レンダリングされてしまう。  
配列が `props` で渡されている場合、Reactはコンポーネントの関数が実行されるたびに新しい配列を作成するため。  

これを避けるには、 `React.memo` でコンポーネントを包含するやり方ではなく、配列を `useMemo` を介して生成されるようにすればよい。

```
const [num, setNum] = React.useState(0);

const numArray = React.useMemo(() => {
  return [num, num + 1, num + 2]
}, [num]);
```

## 参考リンク

- [フックの導入 - React](https://ja.reactjs.org/docs/hooks-intro.html)
- [【React Hooks】useEffectのよくある間違い4選とそれらを回避する方法](https://tyotto-good.com/blog/avoid-useeffect-mistakes)