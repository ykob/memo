# React に関する基礎情報

## フック (hook)

フック(hook)は React 16.8 で追加された機能。  
React 16.8 の正式版がリリースされたのは2019年2月4日。  
それ以前のReactにおける関数コンポーネントはStatelessなものだったが、hookによってStatefullな関数コンポーネントを作成することができるようになった。

フックはAPIとしてはuseから始まる関数名で提供されている。(`useState`, `useEffect`など)  

## カスタムフック

## 副作用 (effect) フック

プログラミングにおける**副作用 (side effect)**とは、ある機能がデータを変化させた際にそれ以降の演算の結果に影響を与えたり、予測しにくい結果を生じさせることを言う。  
関数型プログラミングでは個々の関数が独立して定義されるため、副作用のリスクが小さくなるメリットがあるとも言われる。  

元々ネガティブな意味合いで使われていた副作用だが、Reactにおいてはその限りではなく、DOMやstateの更新を検知して実行したいコードを指して副作用と呼ぶことがある。  
副作用フックはそのための仕組として存在する。  

- クラスコンポーネントの場合 ... `componentDidMount` や `componentDidUpdate` を使う。
- 関数コンポーネントの場合 ... `useEffect` を使う。

`useEffect` はそのコンポーネントが描画される際に毎回呼び出される。  
コンポーネントの `props` が更新されるとそのコンポーネント自体も再描画されるので、 `props` の更新に合わせてある処理を行いたい場合などに利用できる。(Vue.jsにおける `watch` に似ている。)

`useEffect` は非同期的に実行され、ブラウザによる画面更新をブロックしない。大部分において副作用は同期的に行われる必要がないためにそのようになっている。  
副作用の処理を同期的に行いたい場合(レアケース)は、 `useLayoutEffect` という別のフックを利用する必要がある。

## `useMemo` と `useCallback`

`useMemo` と `useCallback` はいずれも基本的にコンポーネントの再描画を最適化するために用意されている。  
再描画の最適化には主に次の2つの方法がある。

1. 特定のレンダリングで実行する必要がある作業の量を削減する。
2. コンポーネントの再描画が必要になる回数を減らす。

`useMemo` はレンダリング内で計算された値を記憶できるようにする。  
小さなキャッシュなようなものであるとも言える。

## コンポーネントのメモ化 `React.memo`

Reactでは基本的に親コンポーネントが再描画されると子コンポーネントも再描画されてしまう。  
親コンポーネントの `state` が更新されると、それに関係しない子コンポーネントも再描画されてしまうということになる。  
 `React.memo` で包含されたコンポーネントは、そのような無関係な更新による再描画から保護される。

 ### 配列が `props` で渡されているコンポーネントのメモ化

通常値が参照渡しされる配列などが `props` に代入されている場合は、コンポーネントをメモ化していてかつ中身が更新されていないとしても、親コンポーネントが再レンダリングされると子も再レンダリングされてしまう。  
配列が `props` で渡されている場合、Reactはコンポーネントの関数が実行されるたびに新しい配列を作成するため。  

これを避けるには、 `React.memo` でコンポーネントを包含するやり方ではなく、配列を `useMemo` を介して生成されるようにすればよい。

```
const [num, setNum] = React.useState(0);

const numArray = React.useMemo(() => {
  return [num, num + 1, num + 2]
}, [num]);
```

## 参考リンク

- [フックの導入 - React](https://ja.reactjs.org/docs/hooks-intro.html)
